package gamma.engine.core.nodes;

import gamma.engine.core.input.InputEvent;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.stream.Stream;

/**
 * Base class for all scene nodes.
 *
 * @author Nico
 */
public class Node {

	/** This node's parent */
	private Node parent = null;
	/** List of children to be added in the next update */
	private final ArrayList<Node> queue = new ArrayList<>();
	/** This node's children */
	private final HashMap<String, Node> children = new HashMap<>();
	/** This node's current state */
	private State state = State.OUTSIDE_TREE;

	/**
	 * Called when the node enters the scene nodes.
	 * Used for initialization.
	 * Node classes must override this to provide their functionalities.
	 */
	protected void onEnter() {

	}

	/**
	 * Called every frame when this node is in the scene nodes.
	 * Node classes must override this to provide their functionalities.
	 *
	 * @param delta Time elapsed since the previous frame in seconds
	 */
	protected void onUpdate(float delta) {

	}

	/**
	 * Called when the node exits the scene nodes.
	 * Used for clean up.
	 * Node classes must override this to provide their functionalities.
	 */
	protected void onExit() {

	}

	/**
	 * Processes this node and all its children recursively.
	 * Children are processed first.
	 * Called every frame when this node is in the scene nodes.
	 *
	 * @param delta Time elapsed since the previous frame in seconds
	 */
	protected final void process(float delta) {
		// Process children first
		this.children.values().removeIf(child -> {
			// Remove child if it is being removed
			if(child.state == State.REMOVING) {
				child.exit();
				child.parent = null;
				return true;
			}
			// Process child
			child.process(delta);
			return false;
		});
		// Add children in queue
		this.queue.forEach(this::addChild);
		this.queue.clear();
		// Update this node
		this.onUpdate(delta);
	}

	/**
	 * Called when the node is added to the scene nodes with {@link Node#addChild(Node)} or {@link SceneTree#changeScene(Node)}..
	 * Calls {@link Node#onEnter()} on this node's children and this node itself.
	 */
	protected final void enter() {
		this.children.forEach((key, child) -> child.enter());
		this.state = State.INSIDE_TREE;
		this.onEnter();
	}

	/**
	 * Sends an input event to this node and its children.
	 * Children receive the input first.
	 *
	 * @param event The input event
	 */
	public final void input(InputEvent event) {
		this.children.forEach((key, child) -> child.input(event));
		this.onInput(event);
	}

	/**
	 * Called when this node receives an input event.
	 * Node classes must override this to provide their functionalities.
	 *
	 * @param event The input event
	 */
	protected void onInput(InputEvent event) {

	}

	/**
	 * Adds a child to this node with an autogenerated key.
	 * Calls {@link Node#enter()} on the added node if this node is inside the scene nodes.
	 * Note that this may cause a {@link java.util.ConcurrentModificationException} if the node is added while the children are being processed.
	 * In that case use {@link Node#queueChild(Node)}.
	 *
	 * @param node The child to add
	 *
	 * @throws IllegalArgumentException If the given node is null
	 * @throws IllegalStateException If the given node already has a parent
	 */
	public final void addChild(Node node) {
		if(node == null) {
			throw new IllegalArgumentException("Child cannot be null");
		} else if(node.parent != null) {
			throw new IllegalStateException("Cannot add " + node + " as child of " + this + " because it already has parent " + node.parent);
		} else {
			String key = node.getClass().getSimpleName();
			if(this.children.containsKey(key)) {
				int index = 2;
				while(this.children.containsKey(key + index)) {
					index ++;
				}
				key = key + index;
			}
			this.children.put(key, node);
			node.parent = this;
			if(this.state == State.INSIDE_TREE) {
				node.enter();
			}
		}
	}

	/**
	 * Adds a child to this node with the given key key.
	 * Calls {@link Node#enter()} on the added node if this node is inside the scene nodes.
	 * Note that this may cause a {@link java.util.ConcurrentModificationException} if the node is added while the children are being processed.
	 * In that case use {@link Node#queueChild(Node)}.
	 *
	 * @param node The child to add
	 * @param key The child's name
	 *
	 * @throws IllegalArgumentException If the given node or key are null
	 * @throws IllegalStateException If the given node already has a parent or if this node already has a child with the given key
	 */
	public final void addChild(String key, Node node) {
		if(node == null) {
			throw new IllegalArgumentException("Child cannot be null");
		} else if(key == null) {
			throw new IllegalArgumentException("Key cannot be null");
		} else if(node.parent != null) {
			throw new IllegalStateException("Cannot add " + node + " as child of " + this + " because it already has parent " + node.parent);
		} else if(this.children.containsKey(key)) {
			throw new IllegalStateException("Cannot add " + node + " as a child of " + this + " because it already has a child with key " + key);
		} else {
			this.children.put(key, node);
			node.parent = this;
			if(this.state == State.INSIDE_TREE) {
				node.enter();
			}
		}
	}

	/**
	 * Checks if this node has a child with the given key.
	 *
	 * @param key The key to check for
	 * @return True if this node has a child with the given key, otherwise false
	 */
	public final boolean hasChild(String key) {
		return this.children.containsKey(key);
	}

	/**
	 * Queues a child to be added in the next {@link Node#process(float)} call, as soon as it is safe to do so.
	 * Unlike {@link Node#addChild(Node)}, this method does not call {@link Node#enter()} and the addition of the child is not immediate.
	 *
	 * @param node The child to add
	 *
	 * @throws IllegalArgumentException If the given node is null
	 */
	public final void queueChild(Node node) {
		if(node == null) {
			throw new IllegalArgumentException("Child cannot be null");
		} else {
			this.queue.add(node);
		}
	}

	/**
	 * Called when the node exits to the scene nodes after {@link Node#removeChild(Node)} or {@link SceneTree#changeScene(Node)} are called.
	 * Calls {@link Node#onExit()} on this node's children and this node itself.
	 */
	protected final void exit() {
		this.children.forEach((key, child) -> child.exit());
		this.onExit();
		this.state = State.OUTSIDE_TREE;
	}

	/**
	 * Removes the given child from this node.
	 * Calls {@link Node#exit()} on the removed node if this node is inside the scene nodes.
	 * Note that this may cause a {@link java.util.ConcurrentModificationException} if the node is removed while the children are being processed.
	 * In that case use {@link Node#queueRemove()}.
	 *
	 * @param node The child to remove
	 *
	 * @throws IllegalArgumentException If the given node is null
	 * @throws IllegalStateException If the given node is not a child of this node
	 */
	public final void removeChild(Node node) {
		if(node == null) {
			throw new IllegalArgumentException("Child cannot be null");
		} else if(node.parent != this) {
			throw new IllegalStateException("Cannot remove child " + node + " from parent " + this + " because its parent is " + node.parent);
		} else {
			node.exit();
			this.children.values().remove(node);
			node.parent = null;
		}
	}

	/**
	 * Removes a child with the given key from this node.
	 * Calls {@link Node#exit()} on the removed node if this node is inside the scene nodes.
	 * Note that this may cause a {@link java.util.ConcurrentModificationException} if the node is removed while the children are being processed.
	 * In that case use {@link Node#queueRemove()}.
	 *
	 * @param name The key of the child to remove
	 *
	 * @throws IllegalStateException If this node does not have a child with the given key
	 */
	public final void removeChild(String name) {
		if(this.children.containsKey(name)) {
			Node node = this.children.get(name);
			node.exit();
			this.children.remove(name);
			node.parent = null;
		} else {
			throw new IllegalStateException("Parent " + this + " does not contain a child with key " + name);
		}
	}

	/**
	 * Queues this node to be removed in the next {@link Node#process(float)} call, as soon as it is safe to do so.
	 * Unlike {@link Node#removeChild(Node)}, this method does not call {@link Node#exit()} and the removal of the node is not immediate.
	 */
	public final void queueRemove() {
		this.state = State.REMOVING;
	}

	/**
	 * Gets this node's parent or null if this node is the root or an orphan.
	 *
	 * @return This node's parent or null if this node is the root or an orphan
	 */
	public final Node getParent() {
		return this.parent;
	}

	/**
	 * Gets the number of children that this node has.
	 *
	 * @return The number of children that this node has
	 */
	public final int getChildCount() {
		return this.children.size();
	}

	/**
	 * Gets a child of this node with the given key or null if this node does not have a child with that key.
	 *
	 * @param name Key of the child to get
	 *
	 * @return A child of this node with the given key or null if this node does not have a child with that key
	 */
	public final Node getChild(String name) {
		return this.children.get(name);
	}

	/**
	 * Returns a {@link Stream} of this node's children for easy iteration.
	 *
	 * @return A {@code Stream} of this node's children for easy iteration
	 */
	public final Stream<Node> getChildren() {
		return this.children.values().stream();
	}

	/**
	 * Checks if this node is inside the scene nodes, i.e., if {@link Node#enter()} has been called.
	 *
	 * @return True if this node is inside the scene nodes, otherwise false
	 */
	public final boolean isInsideTree() {
		return this.state != State.OUTSIDE_TREE;
	}

	/**
	 * Processes this node and its children while in the editor by calling {@link Node#onEditorProcess()}.
	 * Only called from the editor.
	 */
	public final void editorProcess() {
		this.children.forEach((key, child) -> child.editorProcess());
		this.onEditorProcess();
	}

	/**
	 * Called every frame while in the editor.
	 * Used for gizmos and editor functions.
	 * Node classes must override this to provide their functionalities.
	 * Important: do not modify the node while in the editor because the changes are kept.
	 */
	protected void onEditorProcess() {

	}

	/**
	 * Used to keep track of a node's state.
	 */
	private enum State {
		/** The node has been added to the scene nodes */
		INSIDE_TREE,
		/** The node is not in the scene nodes */
		OUTSIDE_TREE,
		/** The node has been queued to be removed from the scene nodes */
		REMOVING
	}
}
